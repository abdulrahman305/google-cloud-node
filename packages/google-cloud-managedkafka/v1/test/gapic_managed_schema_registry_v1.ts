// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import * as protos from '../protos/protos';
import * as assert from 'assert';
import * as sinon from 'sinon';
import {SinonStub} from 'sinon';
import {describe, it} from 'mocha';
import * as managedschemaregistryModule from '../src';

import {protobuf, LocationProtos} from 'google-gax';

// Dynamically loaded proto JSON is needed to get the type information
// to fill in default values for request objects
const root = protobuf.Root.fromJSON(require('../protos/protos.json')).resolveAll();

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getTypeDefaultValue(typeName: string, fields: string[]) {
    let type = root.lookupType(typeName) as protobuf.Type;
    for (const field of fields.slice(0, -1)) {
        type = type.fields[field]?.resolvedType as protobuf.Type;
    }
    return type.fields[fields[fields.length - 1]]?.defaultValue;
}

function generateSampleMessage<T extends object>(instance: T) {
    const filledObject = (instance.constructor as typeof protobuf.Message)
        .toObject(instance as protobuf.Message<T>, {defaults: true});
    return (instance.constructor as typeof protobuf.Message).fromObject(filledObject) as T;
}

function stubSimpleCall<ResponseType>(response?: ResponseType, error?: Error) {
    return error ? sinon.stub().rejects(error) : sinon.stub().resolves([response]);
}

function stubSimpleCallWithCallback<ResponseType>(response?: ResponseType, error?: Error) {
    return error ? sinon.stub().callsArgWith(2, error) : sinon.stub().callsArgWith(2, null, response);
}

function stubAsyncIterationCall<ResponseType>(responses?: ResponseType[], error?: Error) {
    let counter = 0;
    const asyncIterable = {
        [Symbol.asyncIterator]() {
            return {
                async next() {
                    if (error) {
                        return Promise.reject(error);
                    }
                    if (counter >= responses!.length) {
                        return Promise.resolve({done: true, value: undefined});
                    }
                    return Promise.resolve({done: false, value: responses![counter++]});
                }
            };
        }
    };
    return sinon.stub().returns(asyncIterable);
}

describe('v1.ManagedSchemaRegistryClient', () => {
    describe('Common methods', () => {
        it('has apiEndpoint', () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient();
            const apiEndpoint = client.apiEndpoint;
            assert.strictEqual(apiEndpoint, 'managedkafka.googleapis.com');
        });

        it('has universeDomain', () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient();
            const universeDomain = client.universeDomain;
            assert.strictEqual(universeDomain, "googleapis.com");
        });

        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            it('throws DeprecationWarning if static servicePath is used', () => {
                const stub = sinon.stub(process, 'emitWarning');
                const servicePath = managedschemaregistryModule.v1.ManagedSchemaRegistryClient.servicePath;
                assert.strictEqual(servicePath, 'managedkafka.googleapis.com');
                assert(stub.called);
                stub.restore();
            });

            it('throws DeprecationWarning if static apiEndpoint is used', () => {
                const stub = sinon.stub(process, 'emitWarning');
                const apiEndpoint = managedschemaregistryModule.v1.ManagedSchemaRegistryClient.apiEndpoint;
                assert.strictEqual(apiEndpoint, 'managedkafka.googleapis.com');
                assert(stub.called);
                stub.restore();
            });
        }
        it('sets apiEndpoint according to universe domain camelCase', () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({universeDomain: 'example.com'});
            const servicePath = client.apiEndpoint;
            assert.strictEqual(servicePath, 'managedkafka.example.com');
        });

        it('sets apiEndpoint according to universe domain snakeCase', () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({universe_domain: 'example.com'});
            const servicePath = client.apiEndpoint;
            assert.strictEqual(servicePath, 'managedkafka.example.com');
        });

        if (typeof process === 'object' && 'env' in process) {
            describe('GOOGLE_CLOUD_UNIVERSE_DOMAIN environment variable', () => {
                it('sets apiEndpoint from environment variable', () => {
                    const saved = process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
                    process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = 'example.com';
                    const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient();
                    const servicePath = client.apiEndpoint;
                    assert.strictEqual(servicePath, 'managedkafka.example.com');
                    if (saved) {
                        process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = saved;
                    } else {
                        delete process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
                    }
                });

                it('value configured in code has priority over environment variable', () => {
                    const saved = process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
                    process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = 'example.com';
                    const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({universeDomain: 'configured.example.com'});
                    const servicePath = client.apiEndpoint;
                    assert.strictEqual(servicePath, 'managedkafka.configured.example.com');
                    if (saved) {
                        process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = saved;
                    } else {
                        delete process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
                    }
                });
            });
        }
        it('does not allow setting both universeDomain and universe_domain', () => {
            assert.throws(() => { new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({universe_domain: 'example.com', universeDomain: 'example.net'}); });
        });

        it('has port', () => {
            const port = managedschemaregistryModule.v1.ManagedSchemaRegistryClient.port;
            assert(port);
            assert(typeof port === 'number');
        });

        it('should create a client with no option', () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient();
            assert(client);
        });

        it('should create a client with gRPC fallback', () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                fallback: true,
            });
            assert(client);
        });

        it('has initialize method and supports deferred initialization', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            assert.strictEqual(client.managedSchemaRegistryStub, undefined);
            await client.initialize();
            assert(client.managedSchemaRegistryStub);
        });

        it('has close method for the initialized client', done => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            client.initialize().catch(err => {throw err});
            assert(client.managedSchemaRegistryStub);
            client.close().then(() => {
                done();
            }).catch(err => {throw err});
        });

        it('has close method for the non-initialized client', done => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            assert.strictEqual(client.managedSchemaRegistryStub, undefined);
            client.close().then(() => {
                done();
            }).catch(err => {throw err});
        });

        it('has getProjectId method', async () => {
            const fakeProjectId = 'fake-project-id';
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            client.auth.getProjectId = sinon.stub().resolves(fakeProjectId);
            const result = await client.getProjectId();
            assert.strictEqual(result, fakeProjectId);
            assert((client.auth.getProjectId as SinonStub).calledWithExactly());
        });

        it('has getProjectId method with callback', async () => {
            const fakeProjectId = 'fake-project-id';
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            client.auth.getProjectId = sinon.stub().callsArgWith(0, null, fakeProjectId);
            const promise = new Promise((resolve, reject) => {
                client.getProjectId((err?: Error|null, projectId?: string|null) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(projectId);
                    }
                });
            });
            const result = await promise;
            assert.strictEqual(result, fakeProjectId);
        });
    });

    describe('getSchemaRegistry', () => {
        it('invokes getSchemaRegistry without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry()
            );
            client.innerApiCalls.getSchemaRegistry = stubSimpleCall(expectedResponse);
            const [response] = await client.getSchemaRegistry(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaRegistry without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry()
            );
            client.innerApiCalls.getSchemaRegistry = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getSchemaRegistry(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaRegistry with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getSchemaRegistry = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getSchemaRegistry(request), expectedError);
            const actualRequest = (client.innerApiCalls.getSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaRegistry with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRegistryRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getSchemaRegistry(request), expectedError);
        });
    });

    describe('listSchemaRegistries', () => {
        it('invokes listSchemaRegistries without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesResponse()
            );
            client.innerApiCalls.listSchemaRegistries = stubSimpleCall(expectedResponse);
            const [response] = await client.listSchemaRegistries(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSchemaRegistries as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaRegistries as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaRegistries without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesResponse()
            );
            client.innerApiCalls.listSchemaRegistries = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.listSchemaRegistries(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.IListSchemaRegistriesResponse|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSchemaRegistries as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaRegistries as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaRegistries with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.listSchemaRegistries = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.listSchemaRegistries(request), expectedError);
            const actualRequest = (client.innerApiCalls.listSchemaRegistries as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaRegistries as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaRegistries with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaRegistriesRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.listSchemaRegistries(request), expectedError);
        });
    });

    describe('createSchemaRegistry', () => {
        it('invokes createSchemaRegistry without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry()
            );
            client.innerApiCalls.createSchemaRegistry = stubSimpleCall(expectedResponse);
            const [response] = await client.createSchemaRegistry(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.createSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.createSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes createSchemaRegistry without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaRegistry()
            );
            client.innerApiCalls.createSchemaRegistry = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.createSchemaRegistry(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaRegistry|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.createSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.createSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes createSchemaRegistry with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.createSchemaRegistry = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.createSchemaRegistry(request), expectedError);
            const actualRequest = (client.innerApiCalls.createSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.createSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes createSchemaRegistry with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CreateSchemaRegistryRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.createSchemaRegistry(request), expectedError);
        });
    });

    describe('deleteSchemaRegistry', () => {
        it('invokes deleteSchemaRegistry without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.protobuf.Empty()
            );
            client.innerApiCalls.deleteSchemaRegistry = stubSimpleCall(expectedResponse);
            const [response] = await client.deleteSchemaRegistry(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaRegistry without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.protobuf.Empty()
            );
            client.innerApiCalls.deleteSchemaRegistry = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.deleteSchemaRegistry(
                    request,
                    (err?: Error|null, result?: protos.google.protobuf.IEmpty|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaRegistry with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.deleteSchemaRegistry = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.deleteSchemaRegistry(request), expectedError);
            const actualRequest = (client.innerApiCalls.deleteSchemaRegistry as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaRegistry as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaRegistry with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaRegistryRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.deleteSchemaRegistry(request), expectedError);
        });
    });

    describe('getContext', () => {
        it('invokes getContext without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetContextRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetContextRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.Context()
            );
            client.innerApiCalls.getContext = stubSimpleCall(expectedResponse);
            const [response] = await client.getContext(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getContext as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getContext as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getContext without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetContextRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetContextRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.Context()
            );
            client.innerApiCalls.getContext = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getContext(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.IContext|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getContext as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getContext as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getContext with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetContextRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetContextRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getContext = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getContext(request), expectedError);
            const actualRequest = (client.innerApiCalls.getContext as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getContext as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getContext with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetContextRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetContextRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getContext(request), expectedError);
        });
    });

    describe('listContexts', () => {
        it('invokes listContexts without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listContexts = stubSimpleCall(expectedResponse);
            const [response] = await client.listContexts(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listContexts as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listContexts as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listContexts without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listContexts = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.listContexts(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listContexts as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listContexts as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listContexts with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.listContexts = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.listContexts(request), expectedError);
            const actualRequest = (client.innerApiCalls.listContexts as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listContexts as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listContexts with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListContextsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.listContexts(request), expectedError);
        });
    });

    describe('getSchema', () => {
        it('invokes getSchema without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.Schema()
            );
            client.innerApiCalls.getSchema = stubSimpleCall(expectedResponse);
            const [response] = await client.getSchema(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getSchema as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchema as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchema without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.Schema()
            );
            client.innerApiCalls.getSchema = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getSchema(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchema|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getSchema as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchema as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchema with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getSchema = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getSchema(request), expectedError);
            const actualRequest = (client.innerApiCalls.getSchema as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchema as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchema with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getSchema(request), expectedError);
        });
    });

    describe('getRawSchema', () => {
        it('invokes getRawSchema without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.getRawSchema = stubSimpleCall(expectedResponse);
            const [response] = await client.getRawSchema(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getRawSchema as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getRawSchema as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getRawSchema without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.getRawSchema = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getRawSchema(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getRawSchema as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getRawSchema as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getRawSchema with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getRawSchema = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getRawSchema(request), expectedError);
            const actualRequest = (client.innerApiCalls.getRawSchema as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getRawSchema as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getRawSchema with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getRawSchema(request), expectedError);
        });
    });

    describe('listSchemaVersions', () => {
        it('invokes listSchemaVersions without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listSchemaVersions = stubSimpleCall(expectedResponse);
            const [response] = await client.listSchemaVersions(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSchemaVersions as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaVersions as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaVersions without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listSchemaVersions = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.listSchemaVersions(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSchemaVersions as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaVersions as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaVersions with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.listSchemaVersions = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.listSchemaVersions(request), expectedError);
            const actualRequest = (client.innerApiCalls.listSchemaVersions as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaVersions as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaVersions with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaVersionsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.listSchemaVersions(request), expectedError);
        });
    });

    describe('listSchemaTypes', () => {
        it('invokes listSchemaTypes without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listSchemaTypes = stubSimpleCall(expectedResponse);
            const [response] = await client.listSchemaTypes(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSchemaTypes as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaTypes as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaTypes without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listSchemaTypes = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.listSchemaTypes(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSchemaTypes as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaTypes as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaTypes with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.listSchemaTypes = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.listSchemaTypes(request), expectedError);
            const actualRequest = (client.innerApiCalls.listSchemaTypes as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSchemaTypes as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSchemaTypes with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSchemaTypesRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.listSchemaTypes(request), expectedError);
        });
    });

    describe('listSubjects', () => {
        it('invokes listSubjects without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listSubjects = stubSimpleCall(expectedResponse);
            const [response] = await client.listSubjects(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSubjects as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSubjects as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSubjects without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listSubjects = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.listSubjects(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSubjects as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSubjects as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSubjects with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.listSubjects = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.listSubjects(request), expectedError);
            const actualRequest = (client.innerApiCalls.listSubjects as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSubjects as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSubjects with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.listSubjects(request), expectedError);
        });
    });

    describe('listSubjectsBySchemaId', () => {
        it('invokes listSubjectsBySchemaId without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listSubjectsBySchemaId = stubSimpleCall(expectedResponse);
            const [response] = await client.listSubjectsBySchemaId(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSubjectsBySchemaId as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSubjectsBySchemaId as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSubjectsBySchemaId without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listSubjectsBySchemaId = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.listSubjectsBySchemaId(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listSubjectsBySchemaId as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSubjectsBySchemaId as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSubjectsBySchemaId with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.listSubjectsBySchemaId = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.listSubjectsBySchemaId(request), expectedError);
            const actualRequest = (client.innerApiCalls.listSubjectsBySchemaId as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listSubjectsBySchemaId as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listSubjectsBySchemaId with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListSubjectsBySchemaIdRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.listSubjectsBySchemaId(request), expectedError);
        });
    });

    describe('deleteSubject', () => {
        it('invokes deleteSubject without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.deleteSubject = stubSimpleCall(expectedResponse);
            const [response] = await client.deleteSubject(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteSubject as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSubject as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSubject without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.deleteSubject = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.deleteSubject(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteSubject as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSubject as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSubject with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.deleteSubject = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.deleteSubject(request), expectedError);
            const actualRequest = (client.innerApiCalls.deleteSubject as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSubject as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSubject with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSubjectRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.deleteSubject(request), expectedError);
        });
    });

    describe('lookupVersion', () => {
        it('invokes lookupVersion without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaVersion()
            );
            client.innerApiCalls.lookupVersion = stubSimpleCall(expectedResponse);
            const [response] = await client.lookupVersion(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.lookupVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.lookupVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes lookupVersion without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaVersion()
            );
            client.innerApiCalls.lookupVersion = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.lookupVersion(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.lookupVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.lookupVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes lookupVersion with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.lookupVersion = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.lookupVersion(request), expectedError);
            const actualRequest = (client.innerApiCalls.lookupVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.lookupVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes lookupVersion with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.LookupVersionRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.lookupVersion(request), expectedError);
        });
    });

    describe('getVersion', () => {
        it('invokes getVersion without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaVersion()
            );
            client.innerApiCalls.getVersion = stubSimpleCall(expectedResponse);
            const [response] = await client.getVersion(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getVersion without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaVersion()
            );
            client.innerApiCalls.getVersion = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getVersion(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaVersion|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getVersion with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getVersion = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getVersion(request), expectedError);
            const actualRequest = (client.innerApiCalls.getVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getVersion with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getVersion(request), expectedError);
        });
    });

    describe('getRawSchemaVersion', () => {
        it('invokes getRawSchemaVersion without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.getRawSchemaVersion = stubSimpleCall(expectedResponse);
            const [response] = await client.getRawSchemaVersion(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getRawSchemaVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getRawSchemaVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getRawSchemaVersion without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.getRawSchemaVersion = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getRawSchemaVersion(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getRawSchemaVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getRawSchemaVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getRawSchemaVersion with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getRawSchemaVersion = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getRawSchemaVersion(request), expectedError);
            const actualRequest = (client.innerApiCalls.getRawSchemaVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getRawSchemaVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getRawSchemaVersion with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getRawSchemaVersion(request), expectedError);
        });
    });

    describe('listVersions', () => {
        it('invokes listVersions without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listVersions = stubSimpleCall(expectedResponse);
            const [response] = await client.listVersions(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listVersions as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listVersions as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listVersions without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listVersions = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.listVersions(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listVersions as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listVersions as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listVersions with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.listVersions = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.listVersions(request), expectedError);
            const actualRequest = (client.innerApiCalls.listVersions as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listVersions as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listVersions with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListVersionsRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.listVersions(request), expectedError);
        });
    });

    describe('createVersion', () => {
        it('invokes createVersion without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateVersionResponse()
            );
            client.innerApiCalls.createVersion = stubSimpleCall(expectedResponse);
            const [response] = await client.createVersion(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.createVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.createVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes createVersion without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateVersionResponse()
            );
            client.innerApiCalls.createVersion = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.createVersion(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ICreateVersionResponse|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.createVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.createVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes createVersion with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.createVersion = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.createVersion(request), expectedError);
            const actualRequest = (client.innerApiCalls.createVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.createVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes createVersion with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CreateVersionRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.createVersion(request), expectedError);
        });
    });

    describe('deleteVersion', () => {
        it('invokes deleteVersion without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.deleteVersion = stubSimpleCall(expectedResponse);
            const [response] = await client.deleteVersion(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteVersion without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.deleteVersion = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.deleteVersion(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteVersion with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.deleteVersion = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.deleteVersion(request), expectedError);
            const actualRequest = (client.innerApiCalls.deleteVersion as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteVersion as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteVersion with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteVersionRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.deleteVersion(request), expectedError);
        });
    });

    describe('listReferencedSchemas', () => {
        it('invokes listReferencedSchemas without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listReferencedSchemas = stubSimpleCall(expectedResponse);
            const [response] = await client.listReferencedSchemas(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listReferencedSchemas as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listReferencedSchemas as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listReferencedSchemas without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.api.HttpBody()
            );
            client.innerApiCalls.listReferencedSchemas = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.listReferencedSchemas(
                    request,
                    (err?: Error|null, result?: protos.google.api.IHttpBody|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.listReferencedSchemas as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listReferencedSchemas as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listReferencedSchemas with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedHeaderRequestParams = `parent=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.listReferencedSchemas = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.listReferencedSchemas(request), expectedError);
            const actualRequest = (client.innerApiCalls.listReferencedSchemas as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.listReferencedSchemas as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes listReferencedSchemas with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.ListReferencedSchemasRequest', ['parent']);
            request.parent = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.listReferencedSchemas(request), expectedError);
        });
    });

    describe('checkCompatibility', () => {
        it('invokes checkCompatibility without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityResponse()
            );
            client.innerApiCalls.checkCompatibility = stubSimpleCall(expectedResponse);
            const [response] = await client.checkCompatibility(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.checkCompatibility as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.checkCompatibility as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes checkCompatibility without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityResponse()
            );
            client.innerApiCalls.checkCompatibility = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.checkCompatibility(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ICheckCompatibilityResponse|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.checkCompatibility as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.checkCompatibility as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes checkCompatibility with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.checkCompatibility = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.checkCompatibility(request), expectedError);
            const actualRequest = (client.innerApiCalls.checkCompatibility as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.checkCompatibility as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes checkCompatibility with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.CheckCompatibilityRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.checkCompatibility(request), expectedError);
        });
    });

    describe('getSchemaConfig', () => {
        it('invokes getSchemaConfig without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig()
            );
            client.innerApiCalls.getSchemaConfig = stubSimpleCall(expectedResponse);
            const [response] = await client.getSchemaConfig(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaConfig without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig()
            );
            client.innerApiCalls.getSchemaConfig = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getSchemaConfig(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaConfig with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getSchemaConfig = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getSchemaConfig(request), expectedError);
            const actualRequest = (client.innerApiCalls.getSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaConfig with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getSchemaConfig(request), expectedError);
        });
    });

    describe('updateSchemaConfig', () => {
        it('invokes updateSchemaConfig without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig()
            );
            client.innerApiCalls.updateSchemaConfig = stubSimpleCall(expectedResponse);
            const [response] = await client.updateSchemaConfig(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.updateSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.updateSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes updateSchemaConfig without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig()
            );
            client.innerApiCalls.updateSchemaConfig = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.updateSchemaConfig(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.updateSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.updateSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes updateSchemaConfig with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.updateSchemaConfig = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.updateSchemaConfig(request), expectedError);
            const actualRequest = (client.innerApiCalls.updateSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.updateSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes updateSchemaConfig with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.updateSchemaConfig(request), expectedError);
        });
    });

    describe('deleteSchemaConfig', () => {
        it('invokes deleteSchemaConfig without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig()
            );
            client.innerApiCalls.deleteSchemaConfig = stubSimpleCall(expectedResponse);
            const [response] = await client.deleteSchemaConfig(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaConfig without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaConfig()
            );
            client.innerApiCalls.deleteSchemaConfig = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.deleteSchemaConfig(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaConfig|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaConfig with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.deleteSchemaConfig = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.deleteSchemaConfig(request), expectedError);
            const actualRequest = (client.innerApiCalls.deleteSchemaConfig as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaConfig as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaConfig with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaConfigRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.deleteSchemaConfig(request), expectedError);
        });
    });

    describe('getSchemaMode', () => {
        it('invokes getSchemaMode without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode()
            );
            client.innerApiCalls.getSchemaMode = stubSimpleCall(expectedResponse);
            const [response] = await client.getSchemaMode(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaMode without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode()
            );
            client.innerApiCalls.getSchemaMode = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getSchemaMode(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaMode with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getSchemaMode = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getSchemaMode(request), expectedError);
            const actualRequest = (client.innerApiCalls.getSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getSchemaMode with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.GetSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getSchemaMode(request), expectedError);
        });
    });

    describe('updateSchemaMode', () => {
        it('invokes updateSchemaMode without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode()
            );
            client.innerApiCalls.updateSchemaMode = stubSimpleCall(expectedResponse);
            const [response] = await client.updateSchemaMode(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.updateSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.updateSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes updateSchemaMode without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode()
            );
            client.innerApiCalls.updateSchemaMode = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.updateSchemaMode(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.updateSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.updateSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes updateSchemaMode with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.updateSchemaMode = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.updateSchemaMode(request), expectedError);
            const actualRequest = (client.innerApiCalls.updateSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.updateSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes updateSchemaMode with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.UpdateSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.updateSchemaMode(request), expectedError);
        });
    });

    describe('deleteSchemaMode', () => {
        it('invokes deleteSchemaMode without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode()
            );
            client.innerApiCalls.deleteSchemaMode = stubSimpleCall(expectedResponse);
            const [response] = await client.deleteSchemaMode(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaMode without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.SchemaMode()
            );
            client.innerApiCalls.deleteSchemaMode = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.deleteSchemaMode(
                    request,
                    (err?: Error|null, result?: protos.google.cloud.managedkafka.schemaregistry.v1.ISchemaMode|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.deleteSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaMode with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.deleteSchemaMode = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.deleteSchemaMode(request), expectedError);
            const actualRequest = (client.innerApiCalls.deleteSchemaMode as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.deleteSchemaMode as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes deleteSchemaMode with closed client', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.cloud.managedkafka.schemaregistry.v1.DeleteSchemaModeRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.deleteSchemaMode(request), expectedError);
        });
    });
    describe('getLocation', () => {
        it('invokes getLocation without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new LocationProtos.google.cloud.location.GetLocationRequest()
            );
            request.name = '';
            const expectedHeaderRequestParams = 'name=';
            const expectedOptions = {
                otherArgs: {
                    headers: {
                        'x-goog-request-params': expectedHeaderRequestParams,
                    },
                },
            };
            const expectedResponse = generateSampleMessage(
              new LocationProtos.google.cloud.location.Location()
            );
            client.locationsClient.getLocation = stubSimpleCall(expectedResponse);
            const response = await client.getLocation(request, expectedOptions);
            assert.deepStrictEqual(response, [expectedResponse]);
            assert((client.locationsClient.getLocation as SinonStub)
                .getCall(0).calledWith(request, expectedOptions, undefined));
        });
        it('invokes getLocation without error using callback', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new LocationProtos.google.cloud.location.GetLocationRequest()
            );
            request.name = '';
            const expectedHeaderRequestParams = 'name=';
            const expectedOptions = {
                otherArgs: {
                    headers: {
                        'x-goog-request-params': expectedHeaderRequestParams,
                    },
                },
            };
            const expectedResponse = generateSampleMessage(
              new LocationProtos.google.cloud.location.Location()
            );
            client.locationsClient.getLocation = sinon.stub().callsArgWith(2, null, expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getLocation(
                    request,
                    expectedOptions,
                    (
                        err?: Error | null,
                        result?: LocationProtos.google.cloud.location.ILocation | null
                    ) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            assert((client.locationsClient.getLocation as SinonStub)
                .getCall(0));
        });
        it('invokes getLocation with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new LocationProtos.google.cloud.location.GetLocationRequest()
            );
            request.name = '';
            const expectedHeaderRequestParams = 'name=';
            const expectedOptions = {
                otherArgs: {
                    headers: {
                        'x-goog-request-params': expectedHeaderRequestParams,
                    },
                },
            };
            const expectedError = new Error('expected');
            client.locationsClient.getLocation = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getLocation(request, expectedOptions), expectedError);
            assert((client.locationsClient.getLocation as SinonStub)
                .getCall(0).calledWith(request, expectedOptions, undefined));
        });
    });
    describe('listLocationsAsync', () => {
        it('uses async iteration with listLocations without error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
                new LocationProtos.google.cloud.location.ListLocationsRequest()
            );
            request.name = '';
            const expectedHeaderRequestParams = 'name=';
            const expectedResponse = [
                generateSampleMessage(
                    new LocationProtos.google.cloud.location.Location()
                ),
                generateSampleMessage(
                    new LocationProtos.google.cloud.location.Location()
                ),
                generateSampleMessage(
                    new LocationProtos.google.cloud.location.Location()
                ),
            ];
            client.locationsClient.descriptors.page.listLocations.asyncIterate = stubAsyncIterationCall(expectedResponse);
            const responses: LocationProtos.google.cloud.location.ILocation[] = [];
            const iterable = client.listLocationsAsync(request);
            for await (const resource of iterable) {
                responses.push(resource!);
            }
            assert.deepStrictEqual(responses, expectedResponse);
            assert.deepStrictEqual(
                (client.locationsClient.descriptors.page.listLocations.asyncIterate as SinonStub)
                    .getCall(0).args[1], request);
            assert(
                (client.locationsClient.descriptors.page.listLocations.asyncIterate as SinonStub)
                    .getCall(0).args[2].otherArgs.headers['x-goog-request-params'].includes(
                        expectedHeaderRequestParams
                    )
            );
        });
        it('uses async iteration with listLocations with error', async () => {
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new LocationProtos.google.cloud.location.ListLocationsRequest()
            );
            request.name = '';
            const expectedHeaderRequestParams = 'name=';
            const expectedError = new Error('expected');
            client.locationsClient.descriptors.page.listLocations.asyncIterate = stubAsyncIterationCall(undefined, expectedError);
            const iterable = client.listLocationsAsync(request);
            await assert.rejects(async () => {
                const responses: LocationProtos.google.cloud.location.ILocation[] = [];
                for await (const resource of iterable) {
                    responses.push(resource!);
                }
            });
            assert.deepStrictEqual(
                (client.locationsClient.descriptors.page.listLocations.asyncIterate as SinonStub)
                    .getCall(0).args[1], request);
            assert(
                (client.locationsClient.descriptors.page.listLocations.asyncIterate as SinonStub)
                    .getCall(0).args[2].otherArgs.headers['x-goog-request-params'].includes(
                        expectedHeaderRequestParams
                    )
            );
        });
    });

    describe('Path templates', () => {

        describe('projectLocationSchemaRegistryCompatibilitySubjectVersions', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryCompatibilitySubjectVersions";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                subject: "subjectValue",
                version: "versionValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryCompatibilitySubjectVersionsPath', () => {
                const result = client.projectLocationSchemaRegistryCompatibilitySubjectVersionsPath("projectValue", "locationValue", "schemaRegistryValue", "subjectValue", "versionValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSubjectFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName', () => {
                const result = client.matchSubjectFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "subjectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchVersionFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName', () => {
                const result = client.matchVersionFromProjectLocationSchemaRegistryCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "versionValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryConfig', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryConfig";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryConfigPath', () => {
                const result = client.projectLocationSchemaRegistryConfigPath("projectValue", "locationValue", "schemaRegistryValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryConfigName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryConfigName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryConfigName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryConfigName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryConfigName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryConfigName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryConfigPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryContextCompatibilitySubjectVersions', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryContextCompatibilitySubjectVersions";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                context: "contextValue",
                subject: "subjectValue",
                version: "versionValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPath', () => {
                const result = client.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPath("projectValue", "locationValue", "schemaRegistryValue", "contextValue", "subjectValue", "versionValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchContextFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName', () => {
                const result = client.matchContextFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "contextValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSubjectFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName', () => {
                const result = client.matchSubjectFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "subjectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchVersionFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName', () => {
                const result = client.matchVersionFromProjectLocationSchemaRegistryContextCompatibilitySubjectVersionsName(fakePath);
                assert.strictEqual(result, "versionValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextCompatibilitySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryContextConfig', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryContextConfig";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                context: "contextValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryContextConfigPath', () => {
                const result = client.projectLocationSchemaRegistryContextConfigPath("projectValue", "locationValue", "schemaRegistryValue", "contextValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryContextConfigName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryContextConfigName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryContextConfigName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryContextConfigName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryContextConfigName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryContextConfigName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchContextFromProjectLocationSchemaRegistryContextConfigName', () => {
                const result = client.matchContextFromProjectLocationSchemaRegistryContextConfigName(fakePath);
                assert.strictEqual(result, "contextValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextConfigPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryContextMode', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryContextMode";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                context: "contextValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryContextModePath', () => {
                const result = client.projectLocationSchemaRegistryContextModePath("projectValue", "locationValue", "schemaRegistryValue", "contextValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryContextModeName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryContextModeName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryContextModeName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryContextModeName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryContextModeName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryContextModeName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchContextFromProjectLocationSchemaRegistryContextModeName', () => {
                const result = client.matchContextFromProjectLocationSchemaRegistryContextModeName(fakePath);
                assert.strictEqual(result, "contextValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextModePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryContextSchemas', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryContextSchemas";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                context: "contextValue",
                schema: "schemaValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryContextSchemasPath', () => {
                const result = client.projectLocationSchemaRegistryContextSchemasPath("projectValue", "locationValue", "schemaRegistryValue", "contextValue", "schemaValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryContextSchemasName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryContextSchemasName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryContextSchemasName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryContextSchemasName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryContextSchemasName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryContextSchemasName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchContextFromProjectLocationSchemaRegistryContextSchemasName', () => {
                const result = client.matchContextFromProjectLocationSchemaRegistryContextSchemasName(fakePath);
                assert.strictEqual(result, "contextValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaFromProjectLocationSchemaRegistryContextSchemasName', () => {
                const result = client.matchSchemaFromProjectLocationSchemaRegistryContextSchemasName(fakePath);
                assert.strictEqual(result, "schemaValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryContextSubject', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryContextSubject";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                context: "contextValue",
                subject: "subjectValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryContextSubjectPath', () => {
                const result = client.projectLocationSchemaRegistryContextSubjectPath("projectValue", "locationValue", "schemaRegistryValue", "contextValue", "subjectValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryContextSubjectName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryContextSubjectName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryContextSubjectName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryContextSubjectName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchContextFromProjectLocationSchemaRegistryContextSubjectName', () => {
                const result = client.matchContextFromProjectLocationSchemaRegistryContextSubjectName(fakePath);
                assert.strictEqual(result, "contextValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSubjectFromProjectLocationSchemaRegistryContextSubjectName', () => {
                const result = client.matchSubjectFromProjectLocationSchemaRegistryContextSubjectName(fakePath);
                assert.strictEqual(result, "subjectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryContextSubjectVersions', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryContextSubjectVersions";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                context: "contextValue",
                subject: "subjectValue",
                version: "versionValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryContextSubjectVersionsPath', () => {
                const result = client.projectLocationSchemaRegistryContextSubjectVersionsPath("projectValue", "locationValue", "schemaRegistryValue", "contextValue", "subjectValue", "versionValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryContextSubjectVersionsName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryContextSubjectVersionsName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryContextSubjectVersionsName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryContextSubjectVersionsName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectVersionsName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectVersionsName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchContextFromProjectLocationSchemaRegistryContextSubjectVersionsName', () => {
                const result = client.matchContextFromProjectLocationSchemaRegistryContextSubjectVersionsName(fakePath);
                assert.strictEqual(result, "contextValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSubjectFromProjectLocationSchemaRegistryContextSubjectVersionsName', () => {
                const result = client.matchSubjectFromProjectLocationSchemaRegistryContextSubjectVersionsName(fakePath);
                assert.strictEqual(result, "subjectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchVersionFromProjectLocationSchemaRegistryContextSubjectVersionsName', () => {
                const result = client.matchVersionFromProjectLocationSchemaRegistryContextSubjectVersionsName(fakePath);
                assert.strictEqual(result, "versionValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryContextSubjects', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryContextSubjects";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                context: "contextValue",
                subject: "subjectValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryContextSubjectsPath', () => {
                const result = client.projectLocationSchemaRegistryContextSubjectsPath("projectValue", "locationValue", "schemaRegistryValue", "contextValue", "subjectValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryContextSubjectsName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryContextSubjectsName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryContextSubjectsName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryContextSubjectsName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectsName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryContextSubjectsName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchContextFromProjectLocationSchemaRegistryContextSubjectsName', () => {
                const result = client.matchContextFromProjectLocationSchemaRegistryContextSubjectsName(fakePath);
                assert.strictEqual(result, "contextValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSubjectFromProjectLocationSchemaRegistryContextSubjectsName', () => {
                const result = client.matchSubjectFromProjectLocationSchemaRegistryContextSubjectsName(fakePath);
                assert.strictEqual(result, "subjectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryContextSubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistryMode', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistryMode";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistryModePathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistryModePathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistryModePath', () => {
                const result = client.projectLocationSchemaRegistryModePath("projectValue", "locationValue", "schemaRegistryValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistryModePathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistryModeName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistryModeName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryModePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistryModeName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistryModeName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryModePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistryModeName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistryModeName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistryModePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistrySchemas', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistrySchemas";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                schema: "schemaValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistrySchemasPath', () => {
                const result = client.projectLocationSchemaRegistrySchemasPath("projectValue", "locationValue", "schemaRegistryValue", "schemaValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistrySchemasName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistrySchemasName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistrySchemasName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistrySchemasName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistrySchemasName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistrySchemasName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaFromProjectLocationSchemaRegistrySchemasName', () => {
                const result = client.matchSchemaFromProjectLocationSchemaRegistrySchemasName(fakePath);
                assert.strictEqual(result, "schemaValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySchemasPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistrySubject', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistrySubject";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                subject: "subjectValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistrySubjectPath', () => {
                const result = client.projectLocationSchemaRegistrySubjectPath("projectValue", "locationValue", "schemaRegistryValue", "subjectValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistrySubjectName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistrySubjectName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistrySubjectName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistrySubjectName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSubjectFromProjectLocationSchemaRegistrySubjectName', () => {
                const result = client.matchSubjectFromProjectLocationSchemaRegistrySubjectName(fakePath);
                assert.strictEqual(result, "subjectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistrySubjectVersions', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistrySubjectVersions";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                subject: "subjectValue",
                version: "versionValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistrySubjectVersionsPath', () => {
                const result = client.projectLocationSchemaRegistrySubjectVersionsPath("projectValue", "locationValue", "schemaRegistryValue", "subjectValue", "versionValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistrySubjectVersionsName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistrySubjectVersionsName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistrySubjectVersionsName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistrySubjectVersionsName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectVersionsName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectVersionsName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSubjectFromProjectLocationSchemaRegistrySubjectVersionsName', () => {
                const result = client.matchSubjectFromProjectLocationSchemaRegistrySubjectVersionsName(fakePath);
                assert.strictEqual(result, "subjectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchVersionFromProjectLocationSchemaRegistrySubjectVersionsName', () => {
                const result = client.matchVersionFromProjectLocationSchemaRegistrySubjectVersionsName(fakePath);
                assert.strictEqual(result, "versionValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectVersionsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('projectLocationSchemaRegistrySubjects', async () => {
            const fakePath = "/rendered/path/projectLocationSchemaRegistrySubjects";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                subject: "subjectValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('projectLocationSchemaRegistrySubjectsPath', () => {
                const result = client.projectLocationSchemaRegistrySubjectsPath("projectValue", "locationValue", "schemaRegistryValue", "subjectValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromProjectLocationSchemaRegistrySubjectsName', () => {
                const result = client.matchProjectFromProjectLocationSchemaRegistrySubjectsName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromProjectLocationSchemaRegistrySubjectsName', () => {
                const result = client.matchLocationFromProjectLocationSchemaRegistrySubjectsName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectsName', () => {
                const result = client.matchSchemaRegistryFromProjectLocationSchemaRegistrySubjectsName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSubjectFromProjectLocationSchemaRegistrySubjectsName', () => {
                const result = client.matchSubjectFromProjectLocationSchemaRegistrySubjectsName(fakePath);
                assert.strictEqual(result, "subjectValue");
                assert((client.pathTemplates.projectLocationSchemaRegistrySubjectsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('schemaContext', async () => {
            const fakePath = "/rendered/path/schemaContext";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
                context: "contextValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.schemaContextPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.schemaContextPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('schemaContextPath', () => {
                const result = client.schemaContextPath("projectValue", "locationValue", "schemaRegistryValue", "contextValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.schemaContextPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromSchemaContextName', () => {
                const result = client.matchProjectFromSchemaContextName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.schemaContextPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromSchemaContextName', () => {
                const result = client.matchLocationFromSchemaContextName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.schemaContextPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromSchemaContextName', () => {
                const result = client.matchSchemaRegistryFromSchemaContextName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.schemaContextPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchContextFromSchemaContextName', () => {
                const result = client.matchContextFromSchemaContextName(fakePath);
                assert.strictEqual(result, "contextValue");
                assert((client.pathTemplates.schemaContextPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('schemaRegistry', async () => {
            const fakePath = "/rendered/path/schemaRegistry";
            const expectedParameters = {
                project: "projectValue",
                location: "locationValue",
                schema_registry: "schemaRegistryValue",
            };
            const client = new managedschemaregistryModule.v1.ManagedSchemaRegistryClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.schemaRegistryPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.schemaRegistryPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('schemaRegistryPath', () => {
                const result = client.schemaRegistryPath("projectValue", "locationValue", "schemaRegistryValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.schemaRegistryPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchProjectFromSchemaRegistryName', () => {
                const result = client.matchProjectFromSchemaRegistryName(fakePath);
                assert.strictEqual(result, "projectValue");
                assert((client.pathTemplates.schemaRegistryPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLocationFromSchemaRegistryName', () => {
                const result = client.matchLocationFromSchemaRegistryName(fakePath);
                assert.strictEqual(result, "locationValue");
                assert((client.pathTemplates.schemaRegistryPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchSchemaRegistryFromSchemaRegistryName', () => {
                const result = client.matchSchemaRegistryFromSchemaRegistryName(fakePath);
                assert.strictEqual(result, "schemaRegistryValue");
                assert((client.pathTemplates.schemaRegistryPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });
    });
});
